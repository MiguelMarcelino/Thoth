# RabbitMQ Patterns


This is a document summarizing some patterns from RabbitMQ.

Before diving into the meat of this document, there is something in the intro which I found particularly interesting, which was the separation between critical parts of the system and everything else around those critical parts. Making the system's core as simple as possible allows it to be reliable and to keep working as intended for a long time. Furthermore, making it independent of other components allows failures in those components to remain isolated. This demonstrates how a system's architecture is the first layer of protection against failures. Designing for failure should be done from the system's inception, and should not be an afterthought that "plugs in" to an existing solution.

Enough of that! Let's move on to the patterns. In no particular order, here we go!

## RabbitMQ Messaging patterns


### Don't use `sendToQueue`
- It is generally a bad practice to just send items to the queue. Despite having some control over the senders, the receivers are unpredictable, and we never know how many are indeed working (in essence, we are trying to send letters with constantly changing mailboxes)
- The solution is to use a message broker to manage message traffic. This way we can ensure that messages are always properly received. As specified in the doc: "_The dynamic nature of queues and bindings means that you are likely to cause problems by having a message producer assume a specific queue is always there._"

### Sending data vs IDs
- Sending all the data can be positive: We avoid having to do extra processing on the receiving end to retrieve the data
	- This can be ideal if the sender and receiver do not share the same databases
- Sending IDs means faster queues and also better safety
	- Sending less data implies shorter messages, which also improves queuing performance
	- With IDs, receivers are forced to verify that data exists before proceeding, which is good for the overall safety of the system

### Message Types
- Some message types identified for RabbitMQ
	- `Event Message`: a document that describes something that already happened - including any data associated with the event
	- `Command` Message: a document that contains data for a command to execute, or work to be done
	- `RequestMessage`: similar to a command, this document also contains information on how to reply to the request
	- The request meta-data will include information on how that response should be sent.

### Event Messages with Pub/Sub
- It is common for messages to be named according to a hierarchy (e.g. `student.enrolled`, `program.completed`)
	- Names reference objects and imply an action to happen to those objects
- Events work on a publish-subscribe model
	- They are temporal, which means they are received by any subscriber active at the time the event is sent
	- A fanout exchange is sued to ensure that bound queues get a copy of every message (ignoring any routing key that specified in the binding or message).
	- To prevent messages from piling up in queues, each subscriber has an auto-delete queue, which deletes the queue when the subscriber disconnects. (or this can be put in another queue while waiting for other subscribers to come online)
- Rabbit's TTL allows us to simply drop old messages
- Pub/sub is not good to guarantee that messages are only processed once

### Command messages with point-to-point
- Command names should represent a high level concept, not specific details.
	- Send the details in the message's document
- Point-to-point channel: An exchange that uses routing keys to send the message to a single queue.
- Message idempotence: A message should only be executed once
	- We may have to identify messages through a unique identifier (a _sha_, for instance)

### Request/Response with Reply-to and correlation ID
- Two pieces of information must be included in a message if a response is expected:
	- Correlation ID: ID generated by the requestor handler that uniquely identifies the request
	- The address of the private reply-to queue. This queue is used to send the response for the initial request
- The reply-to-queue is one place where we don't want to dynamically send our message. For this specific case, using `sendToQueue` is ideal.
- Important aspects of request response
	- The request is idempotent: it does not change the state of the system (A command, on the other hand, can be used to change the system's state.)
	- The request handler responds within a reasonable time
	- Responses can be dropped if the requestor becomes unavailable (auto-delete queues)

### Status updates with asynchronous response
- To have an asynchronous overview over the system, one can combine commands with events
	- Using request/response is not ideal if events take hours to run (because you have no overview of the intermediate state of jobs)
	- By using a command (e.g `job.run`) and allowing the receivers to publish their own updates, we can decouple job consumers from producers.
	- Updates can be published in the same `jobs` queue, but with an appropriate routing key (e.g. `job.status.changed`)

### Handling bad messages with Dead letter exchanges
- Dead letter exchange (dlx): Holds any message that needs to be put to the side because of a failure
- Conditions to put a message in a dlx:
	- Explicit reject of a message
	- A `nack` of a message with `requeue=false` set
	- The TTL of a message elapsing
	- The queue's message count growing beyond its maximum allowed number
- Handling dead messages
	- Routing to a queue, sending a notification about the dead letter
	- Re-routing to the original queue, using the dead letter “count” property to limit the number of retries
	- Using the delayed message exchange plugin to retry the message at a later time
	- Stacking up dead letters in a queue that is analysed manually


<hr>

Related to: [event-streaming](event-streaming.md)